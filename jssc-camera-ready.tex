%*************************************************************************************************************
%*************************************************************************************************************
%**************************Journal of Systems Science and Complexity (JSSC)***********************************
%*************************************************************************************************************
%*************************************************************************************************************
% This is the model of the standard format of articles published on Journal of Systems Science and Complexity.
% But it is not a .cls or .sty file so you should fill the concrete content directly into this model.
% Please read through the whole guidance marked by "%" before you type according to the guidance.
% After "\end{document}", an article is attached just for an example and you can refer to it.
%*************************************************************************************************************

\documentclass{article}
%\input{vatola.sty}
\usepackage{vatola}
%************************************************************
%Beginning of the head of the tex file of JSSC. You can skip.
%************************************************************
\pagestyle{empty} \oddsidemargin -0.54cm \headheight=16pt
\headsep=20pt
%\footheight=0pt
\footskip=20pt \topmargin 0.79cm \evensidemargin 0pt
\textwidth=14.5 true cm \textheight=20.6 true cm
\usepackage{lastpage}
\usepackage{epsfig}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
%------------------------------------------------------------
\def\cdd{\mbox{\boldmath$\cdot$}~}
% name defs.tex
%\catcode`@=11
\makeatletter
\def\@oddfoot{\hfill}

\newcount\shumeicount
%------------------------------------------------------------
% \setshumei{title page heading}{odd page heading}{even page heading}
\def\setshumei#1#2#3{%
  \shumeicount=\count0
  \def\@oddhead{%
    \raise-5pt\hbox to0pt{\vrule width\hsize height 0pt depth 0.4pt\hss}\relax
    \ifnum \shumeicount=\count0
      \raise-7pt\hbox to0pt{\vrule width\hsize height 0pt depth 0.4pt\hss}\relax
      #1
    \else
      \ifodd\count0
        #2
      \else
        #3
       \fi
     \fi
  }%
}
%\catcode`@=\active
\makeatother

%------------------------------------------------------------
\makeatletter
\def\@oddfoot{\hfill}
\newcount\shujiaocount
\def\setshujiao{%
  \shujiaocount=\count0
  \def\@oddfoot{%
      \ifodd\count0
         %\hfill\hbox to0pt{\hss\epsfig{figure=spr.eps,height=12pt}}
      \else
        %\epsfig{figure=spr.eps,height=12pt}
      \fi
  }%
}
%\catcode`@=\active
\makeatother


%----------------- \biaoti{Title}{Author}{}{}-------------
\def\biaoti#1#2#3#4{{
  \vspace*{0.3cm}
  \begin{flushleft} \Large\bf #1\end{flushleft}
  \vspace*{-0.2cm}
      \begin{flushleft}
      \bf #2
      \end{flushleft}
      \footnotetext{\hspace{-6mm} #3\\ #4}}}
%------------\dshm{Year}{Vol.}{Title}{Author}-------------

\def\dshm#1#2#3#4
{\setshumei{J Syst Sci Complex (#1) #2:
{\thepage--\pageref{LastPage}}\hfill}
            {\hfill {\small #3}\hfill\hbox to0pt{\hss\thepage}}
            {\hbox to0pt{\thepage\hss}\hfill {\small #4}\hfill
            }
            \setshujiao}
%-----------\drd{Received: Month Date, Year}-----------------------------
%----------------------------------------------------------------------
\def\drd#1#2
{{\vskip 1cm\small \begin{flushleft}
 #1 \\
 #2\\
%Accepted: #3/~Published online: #4\\
\copyright The Editorial Office of JSSC \&  Springer-Verlag Berlin
Heidelberg 2010
\end{flushleft}}}
%-------------\dab{Abstract}{Keywords}------------------------------------
\def\dab#1#2{\noindent {{\small\bf Abstract~~}}{{\small #1}}
            \vskip 0.1cm
             \noindent{{\small\bf Key words~~}}{{\small #2}}
                      }
%-------------\dse{Theorem/Corollary/Proposition/Lemma~~Number}-----------
\def\dse#1{\vskip 0.6cm\noindent
        {\large\bf #1}
        \vskip 0.4cm}
%-------------------------------------------------------------------------
\def\rf#1#2{\parindent=0pt\hangindent=0.6cm\hangafter=1\small
            \parbox[t]{0.6cm}{[#1]}#2\par}
\def\rfne{\vskip 0.5cm  \centerline{\bf References} \vskip 0.5cm
               \parindent 0pt}
\def\dd{{\rm d}}  \def\ee{{\rm e}}
\def\dsee#1{\vskip 0.3cm \noindent{\bf #1} \vskip 0.2cm}
\def\dseee#1{\vskip 0.2cm \noindent{\bf #1} \vskip 0.2cm}
%---------------------------------------------------------------------


%************************************************************
%End of the head of the tex file of JSSC.
%************************************************************




%************************************************************
%Some macro files, you can add more
%************************************************************
%\input{amssym.def}
\usepackage{graphicx}
\usepackage{amsfonts}
%\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{pgf,tikz}
\usepackage{epstopdf}
\usetikzlibrary{shapes,arrows,automata}

\usepackage[noend,ruled]{algorithm2e}
\SetInd{2.7ex}{1.5ex}
\LinesNumbered
\SetKwBlock{Block}{begin}{end} \SetKwFor{While}{while}{do}{}
\SetKwFor{ForAll}{for all}{do}{} \SetKwFor{For}{for}{do}{}
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{}
\newcommand{\KwAnd}{{\bf and}}
\newcommand{\Kwor}{{\bf or}}
\newcommand{\KwNot}{{\bf not}}
\SetAlgoSkip{medskip}

%************************************************************

%************************************************************
%Some user-defined commands, you can add more
%************************************************************
\newcommand{\rulex}{\hfill\rule{1mm}{3mm}}
\def\ay{\arraycolsep=1.5pt}

\newcommand{\rank}{{\rm rank}}
\newcommand{\while}{{\rm while}}
\newcommand{\oror}{{\rm or}}
\newcommand{\ifif}{{\rm if}}
\newcommand{\elif}{{\rm elseif}}
\newcommand{\then}{{\rm then}}
\newcommand{\els}{{\rm else}}
\newcommand{\head}{{\rm head}}
\newcommand{\tail}{{\rm tail}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\define}{\widehat{=}}
\newcommand{\xx}{\mathbf{x}}
\newcommand{\NTI}{{\bf NTI}}
\newcommand{\SNTI}{{\bf SNTI}}
\newcommand{\WNTI}{{\bf WNTI}}

%************************************************************



%*************************************************************************************************************
%*************************************************************************************************************
%*************************************************************************************************************
%***Beginning of the article! Please fill the content of your articles according to the guidance.
%*************************************************************************************************************
%*************************************************************************************************************
%*************************************************************************************************************
\setcounter{page}{1}
\begin{document}


%*************************************************************************************************************
\biaoti{DISCOVERING NON-TERMINATING INPUTS FOR MULTI-PATH POLYNOMIAL PROGRAMS$^*$}
{Jiang LIU \cdd Ming XU \cdd Naijun ZHAN \cdd Hengjun ZHAO}
{Jiang LIU \\ {\it Chongqing Key Lab. of Automated Reasoning and Cognition, CIGIT, CAS, Chongqing, China}. \\E-mail: liujiang@cigit.ac.cn. \\
Ming XU \\
{\it Department of Computer Science and Technology, East China Normal University, Shanghai, China}. \\ E-mail: mxu@cs.ecnu.edu.cn.\\
Naijun ZHAN\\
{\it State Key Lab. of Computer Science, Institute of Software, Chinese Academy of Sciences, Beijing, China}. E-mail: znj@ios.ac.cn.\\
Hengjun ZHAO (corresponding author)\\
{\it State Key Lab. of Computer Science, Institute of Software, Chinese Academy of Sciences, Beijing, China}. E-mail: zhaohj@ios.ac.cn.}
{$^*$This research was supported by National Basic Research Program of China (No. 2014CB340700), National Science and Technology Major Project of China (No. 2012ZX01039-004), NSFC (Nos. 91118007, 11071273, 61202131), cstc2012ggB40004, SRFDP (No. 20130076120010), and the Open Project of Shanghai Key Lab. of Trustworthy Computing (No.~07dz22304201307).}
%*************************************************************************************************************

%*************************************************************************************************************
%The submission date of your article. For example: \drd{Received: June 8, 2006}
%*************************************************************************************************************
\drd{DOI: }{Received: July 10, 2012}{ / Revised: September 12, 2013}

%*************************************************************************************************************
% The page header of the article.
% \dshm{Year}{Volume}{The capitalized RUNNING HEAD of your article with less than 48 letters}{The capitalized
% AUTHORS list with $\cdot$ separating different names or one can type "The name of the first author et al."
% if there are more than 4 authors.}
%*************************************************************************************************************

\dshm{20XX}{XX}{DISCOVERING NON-TERMINATING INPUTS FOR MPPS}{JIANG LIU $\cdot$ MING XU $\cdot$ NAIJUN ZHAN $\cdot$ HENGJUN ZHAO}

%*************************************************************************************************************
% \dab{The abstract}{Keywords}
%*************************************************************************************************************
\dab{We investigate the termination problems of multi-path polynomial programs (MPPs) with equational loop guards. To establish sufficient conditions for termination and nontermination simultaneously, we first propose the notion of strong/weak non-termination which under/over-approximates non-termination. Based on polynomial ideal theory, we show that the set of all strong non-terminating inputs (SNTI) and weak non-terminating inputs (WNTI) both correspond to the real varieties of certain polynomial ideals. Furthermore, we prove that the variety of SNTI is computable, and under some sufficient conditions the variety of WNTI is also computable. Then by checking the computed SNTI and WNTI varieties in parallel, termination properties of a considered MPP can be asserted. As a consequence, we establish a new framework for termination analysis of MPPs.}{Termination analysis, polynomial programs, polynomial ideals.}

%*************************************************************************************************************
%*************************************************************************************************************
% Beginning of the text! Please input the content of your articles.
% The title of each section should be typed like "\dse{1~~Introduction}", \dsee{2.1~~The Lemmas} for the
% secondary titles, and \dseee{3.1.1~~The discrete case} for the thirdly ones.
%*************************************************************************************************************
%*************************************************************************************************************

\dse{1~~Introduction}

Termination analysis plays an important role in program verification and testing, and has attracted an increasing attention recently [1, 2]. However, the decision problem of program termination is equivalent to the famous halting problem [3], and hence is undecidable. Thus, a complete method for termination analysis for programs, even for the general linear or polynomial program, is impossible [4, 5, 6]. To achieve positive results, a practical way analogous to [7] is to establish sufficient conditions for termination and nontermination simultaneously for a considered class of programs, and then check these conditions in parallel. We adopt this strategy of termination analysis in this work.

In this paper, we use multi-path polynomial programs (MPPs) as program models for termination analysis. The MPP model proposed in [5] is an expressive class of loops with multiple paths, polynomial loop guards and assignments, that enable practical code abstraction and analysis. It was proved in [5] that the termination problem of MPPs is generally undecidable. To get some computational results, we restrict to MPPs in the context whose loop guards are polynomial equations.

The semantics of an MPP with $\ell$ paths can be explained as follows. Given an input $\xx \in \mathbb{R}^n$, if at the first iteration $\xx$ satisfies the loop guard, then one of the multiple paths in the loop body will be nondeterministically selected and the corresponding assignment will be used to update the value of $\xx$, which results in $\ell$ possible values of $\xx$; at each following iteration, we repeat the same kind of loop guard test and nondeterministic assignment for each of the possible values of $\xx$ obtained so far. Thus the execution of an MPP on input $\xx \in \mathbb{R}^n$ produces a tree structure of execution paths, which is caused by the multi-paths in the considered program model.

An input $\xx$ is called a non-terminating input if the execution tree on $\xx$ has an infinite path. Given an MPP, we aim to compute an explicit representation for the set of all non-terminating inputs (NTI), or certain kinds of approximations of NTI. The theory of polynomial ideals serves as a critical tool for developing our approach.

The basic idea can be explained using a very simple example:
\[
\while \quad (G(x)=0) \quad \{x:=p(x);\} \enspace .
\]
The above MPP is composed of a single program variable $x$, the loop guard $G(x)=0$ and the polynomial assignments $p(x)$. If the MPP is non-terminating upon an input $x \in \mathbb{R}$, then $x,p(x),p(p(x)),\ldots$ must persistently satisfy $G(x)=0$, i.e. $G(x)=G(p(x))=G(p(p(x)))=\cdots=0$. Thus any non-terminating input is a common real root of the set of polynomials $\mathcal{G}\,\define\,\{G(x),G(p(x)),G(p(p(x))),\ldots\}$, or equivalently, an element in the real variety of the ideal $\I$ generated by $\mathcal{G}$. By a well-known result in polynomial ideal theory, $\I$ is generated by a finite number of elements in $\I$. If this finite set of generators of $\I$ can be computed, their common real roots comprise NTI.

For general MPPs with more than one paths, the NTI is not directly connected to the real variety of a polynomial ideal. Instead, we propose the notions of strong and weak non-termination, such that the set of all strong non-terminating inputs (SNTI) is a \emph{subset} of NTI, and the set of all weak non-terminating inputs (WNTI) is a \emph{superset} of NTI. Therefore the non-emptiness of SNTI is a sufficient condition for non-termination, and the emptiness of WNTI is a sufficient condition for termination. Furthermore, both SNTI and WNTI are shown to be real varieties of certain polynomial ideals, of which a finite set of generators can be computed (at least under some sufficient conditions). Thus for any MPP, its SNTI and WNTI can be investigated simultaneously for a better result of termination analysis. The proposed approach will be illustrated by some examples.

\dsee{1.1~~Related work}
In the past, most well-established work on termination analysis can only be applied to linear programs, whose guards and assignments are linear. A classical method for establishing termination of a program, either linear or polynomial, makes use of a well-founded domain together with the so-called \emph{ranking function} that maps the state space of the program to the domain. For single-path linear programs, Col\'{o}n and Sipma utilized polyhedral cones to synthesize linear ranking functions [8]. Podelski and Rybalchenko, based on Farkas' lemma, presented a complete method to find linear ranking functions if they exist [9]. These methods pay more attention to the search for ranking functions than to the inherent structure of loops, while Tiwari first noticed that the termination of a class of simple linear loops is closely related to the eigenvalues of assignment matrix, and proved that the termination problem of linear programs is decidable over $\mathbb{R}$ [4]. This theory was further developed by Braverman [6] and Xia et al. [10, 11]. Xu et~al. also developed Tiwari's work by constructing non-terminating witnesses [12, 13].

It was shown in [5] that the termination of MPPs is undecidable by reduction from Diophantine equations. However, effective methods that are incomplete or relatively complete for analyzing termination still exist. Bradley et~al. proposed an approach to proving termination over $\mathbb{R}$ through finite difference trees [5]. Cook et~al. [14] devised an algorithm to under-approximate the \emph{weakest preconditions} for termination using decidable theories. Typically, with the development of computer algebra, more and more techniques from symbolic computation, for instance, Gr\"{o}bner basis [15, 16], quantifier elimination [17] and recurrence relation [18, 19], are borrowed and successfully applied to the verification of  programs. Certainly, these techniques can also be applied to polynomial programs to discover termination or non-termination proofs. Chen et~al. proposed a relatively complete (w.r.t. a given template) method for generating polynomial ranking functions over $\mathbb{R}$ by reduction to semi-algebraic system solving [20]. On the other hand, Gupta et~al. proposed a practical method to search for counter-examples of termination [21], by first generating lasso-shaped [22] candidate paths and then checking the feasibility of the ``lassoes" using constraint solving. Velroyen and R\"{u}mmer applied invariants to show that terminating states of a program are unreachable from certain initial states, and then identified these ``bad'' initial states by constraint-solving techniques [23]. Brockschmidt et~al. detected non-termination and Null Pointer Exceptions for \textsf{Java Bytecode} by constructing and analyzing termination graphs, and implemented a termination prover \textsf{AProVE} [24].

For more general programs, many other techniques, like predicate abstraction, parametric abstraction, fair assumption, Lagrangian relaxation, semidefinite programming, sum of squares and curve fitting [25, 26], and so on, have been successfully applied.


\paragraph{Organization.}
The remainder of this paper is organized as follows. In Section~2, some concepts and results on polynomial ideals are reviewed. In Section~3, we first introduce MPPs and then define the notions of non-termination, strong/weak non-termination. In Sections 4 and 5 we show how to compute the set of all strong and weak non-terminating inputs of MPPs respectively. Finally we draw a conclusion in Section~6.


\dse{2~~Preliminaries}

In this section, we briefly recall some basic concepts and results on computational algebraic geometry, which serve as the theoretical tool for dealing with non-terminating inputs. For a detailed exposition to this subject, please refer to [27]. Throughout this paper, we use $\mathbb{N}, \mathbb{Q}, \mathbb{R}$ to denote the set of natural, rational, and real numbers, respectively.

{\bf Definition 1} (Ideal)~~{Let $\xx=(x_1,x_2,\ldots,x_n)$ be a vector of variables. A subset $\I$ of the polynomial ring $\mathbb{Q}[\xx]$ is an \emph{ideal} if it satisfies:
\begin{itemize}
\item[(i)] $0 \in \I$;
\item[(ii)] if $p,q \in \I$, then $p+q \in \I$;
\item[(iii)] if $p \in \I$ and $r \in \mathbb{Q}[\xx]$, then $rp \in \I$.
\end{itemize}}

{\bf Definition 2} (Variety)~~{Given a field $\mathbb{K}$ extending $\mathbb{Q}$, the \emph{variety} defined by $P \subseteq \mathbb{Q}[\xx]$ is $\V(P)=\{\xx \in \mathbb{K}^n \ | \ \forall \ p \in P \ : \ p(\xx)=0 \}$. The \emph{real variety} of $P$ is the intersection of $\V(P)$ and $\mathbb{R}^n$, i.e., $\V(P) \cap \mathbb{R}^n$.}

Let $P$ be a nonempty subset of $\mathbb{Q}[\xx]$. It is easy to verify that
\[
\left\{\sum_{i=1}^k r_i p_i \ | \ k \in \mathbb{N}, \ r_i \in \mathbb{Q}[\xx],\ p_i \in P \right\}
\]
is an ideal, denoted by $\langle P\rangle$, and $P$ is called a set of \emph{generators}, or a \emph{basis} of $\langle P \rangle$. In particular, if $P$ is a finite set $\{p_1,p_2,\ldots,p_k\}$, then $\langle P \rangle$ is written as $\langle p_1,p_2,\ldots,p_k \rangle$. An ideal $\I$ is called \emph{principal} if it can be generated by a single element, i.e., $\I=\langle p \rangle$ for some $p\in \mathbb{Q}[\xx]$. It is easy to verify that $\V(P)=\V(\langle P \rangle)$ for any $P \subseteq \mathbb{Q}[\xx]$.

%%label{basis}
{\bf Theorem 1} (Hilbert's Basis Theorem)~~{\it Every ideal $\I \subseteq \mathbb{Q}[\xx]$ has a finite number of generators, i.e., $\I=\langle p_1,p_2,\ldots,p_k \rangle$ for some $p_1,p_2,\ldots,p_k \in \I$.}

In particular, for any $\I=\langle p_1,p_2,\ldots,p_k \rangle$, a unique \emph{(reduced) Gr\"{o}bner basis} of $\I$ can be computed using Buchberger's algorithm, under a fixed \emph{monomial ordering}. Using Gr\"{o}bner basis, the problems of deciding membership of an element in an ideal, testing equality or inclusion of ideals, and so on, can be effectively solved; a Gr\"obner basis is also helpful in checking whether a given ideal is principal.

Given an ideal $\I=\langle p_1,p_2,\ldots,p_k \rangle$, by applying so-called real-solution-isolation algorithms [28, 29] to the system of polynomial equations $p_i(\xx)=0$ for $1 \leq i \leq k$, the emptiness of the real variety $\V(\I) \cap \mathbb{R}^n$ can be checked; and if it is nonempty and is zero-dimensional, the finite set of points in $\V(\I) \cap \mathbb{R}^n$ can be isolated using arbitrarily small cubes (with rational endpoints).

All the above mentioned algorithms have been well-implemented in the computer algebra system {\sc Maple}.

The following result can be derived from Hilbert's Basis Theorem.

%label{ascending}
{\bf Theorem 2} (The Ascending Chain Condition)~~{\it Let $\I_1 \subseteq \I_2 \subseteq \I_3 \subseteq \cdots$ be an ascending chain of ideals in $\mathbb{Q}[\xx]$. Then there exists an integer $N$ such that $\I_N=\I_{N+1}=\I_{N+2}=\cdots$.\footnotemark \footnotetext{Here $\I_N$ is called the \emph{fixed point} of this chain.}}

\dse{3~~Multi-path Polynomial Programs and Non-termination}

    \dsee{3.1~~Multi-path Polynomial Programs}
    {\bf Definition 3} (MPP with Equational Loop Guard)~~{A \emph{multi-path polynomial program} with \emph{equational} loop guard and $\ell$ paths is of the form
\begin{equation}\label{eqn:MPP}
\while \quad (G(\xx)=0) \quad \left\{
\begin{array}{ll}
   & \quad \xx:= {\bf A}_1(\xx); \\
|| & \quad \xx:= {\bf A}_2(\xx); \\
   & \quad \vdots \\
|| & \quad \xx:= {\bf A}_{\ell-1}(\xx); \\
|| & \quad \xx:= {\bf A}_{\ell}(\xx); \\
\end{array}
\right\} \enspace ,
\end{equation}
where
\begin{itemize}
\item $\xx \in \mathbb{R}^n$ denotes a vector of program variables;
\item $G(\xx) \in \mathbb{Q}[\xx]$ is a polynomial and $G(\xx)=0$ is the equational loop guard;
\item ``$||$'' interprets an {\it exclusive choice} of the $\ell$ paths;
\item ${\bf A}_i \in \mathbb{Q}^n[\xx]$ for $1 \leq i \leq \ell$ corresponding to each path is a vector of polynomials describing \emph{simultaneous} assignments for all program variables.
\end{itemize}}

Note that
\begin{enumerate}
\item[1)] MPP~(\ref{eqn:MPP}) allows arbitrary Boolean combinations of polynomial equations of the form $\bigvee_{i=1}^M \bigwedge_{j=1}^{N_i} G_{ij}(\xx)=0$ as loop guard, and assuming $G(\xx)=0$ would not lose any generality, since
    \begin{equation}\label{eqn:guard}
    \left[ \bigvee_{i=1}^M \bigwedge_{j=1}^{N_i} G_{ij}(\xx) = 0 \right]  \Longleftrightarrow \left[ \prod_{i=1}^M \sum_{j=1}^{N_i} [G_{ij}(\xx)]^2 = 0 \right] \enspace .
    \end{equation}
\item[2)] Initial conditions on $\xx$ are not specified, since we are aiming to compute the set of all non-terminating inputs (as real varieties) for a given MPP; nevertheless, equational initial conditions on $\xx$ can be easily taken into account by manipulation of corresponding ideals.
\end{enumerate}

{\bf Example 1}~~{Consider the following MPP
\[
\begin{array}{l}
\while \quad (x-z^3=0 \vee y-z^2=0) \\
\qquad \left\{
\begin{array}{ll}
 & \quad (x,y,z) := (x,y+2z+1,z+1); \\
|| & \quad (x,y,z) := (x-3y+3z-1,y+2z-1,z-1); \\
\end{array}
\right\} \enspace  .\\
\end{array}
\]
According to (\ref{eqn:guard}), the loop guard $y-z^2=0 \vee x-z^3=0$ can be transformed to $(x-z^3)^2 \times (y-z^2)^2=0$, or equivalently $(x-z^3) \times (y-z^2)=0$. There are two exclusive simultaneous assignments, i.e., $(x,y,z):=(x,y+2z+1,z+1)$ and $(x,y,z):=(x-3y+3z-1,y+2z-1,z-1)$, which can be named by ${\bf A}_1$ and ${\bf A}_2$ in the manner of MPP~(\ref{eqn:MPP}). }

    \dsee{3.2~~The Execution of MPPs}
    We associate with each ${\bf A}_i$ in MPP~(\ref{eqn:MPP}) a different symbol $a_i$ indexed by $i$ for $1 \leq i \leq \ell$. Then the execution of MPP~(\ref{eqn:MPP}) on input $\xx \in \mathbb{R}^n$ can be graphically represented as a \emph{labeled execution tree} illustrated by Figure~\ref{fig:exe-tree}. The nodes in the execution tree are elements in $\mathbb{R}^n$. A directed edge labeled by $a_i$ stands for the execution of assignment ${\bf A}_i$, and points to the updated value given by the execution of ${\bf A}_i$. Formally,

{\bf Definition 4} (Execution Tree)~~{The \emph{execution tree} is defined inductively as:
\begin{itemize}
\item the \emph{root} is $\xx$;
\item for any node $\xx'$ in the tree, it is a \emph{leaf node} if $G(\xx') \neq 0$; otherwise $\xx'$ has $\ell$ \emph{children} ${\bf A}_1(\xx'), {\bf A}_2(\xx'), \ldots, {\bf A}_{\ell}(\xx')$, and there is a \emph{directed edge} connecting $\xx'$ and ${\bf A}_i(\xx')$, labeled by $a_i$, for any $1 \leq i \leq \ell$.
\end{itemize}}

\begin{figure}
\begin{minipage}[t]{0.5\linewidth}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
\node[state,rectangle](q1){$\xx$};
\node[state,rectangle](q3)[below of=q1]{$\cdots$};
\node[state,rectangle](q2)[left of=q3]{${\bf A}_1(\xx)$};
\node[state,rectangle](q4)[right of=q3]{${\bf A}_{\ell}(\xx)$};
\node[state,rectangle](q6)[below of=q2]{$\cdots$};
\node[state,rectangle](q5)[left of=q6]{${\bf A}_1({\bf A}_1(\xx))$};
\node[state,rectangle](q7)[right of=q6]{${\bf A}_{\ell}({\bf A}_1(\xx))$};

\node[state,rectangle,white](q8)[below of=q4]{};
\node[state,rectangle,white](q9)[below of=q5]{};
\node[state,rectangle,white](q10)[below of=q7]{};

\draw[->](q1)edge[swap](q2); \draw[->](q1)edge[swap](q3);
\draw[->](q1)edge[swap](q4); \draw[->](q2)edge[swap](q5);
\draw[->](q2)edge[swap](q6); \draw[->](q2)edge[swap](q7);
\draw[->](q4)edge[swap,dotted](q8);
\draw[->](q5)edge[swap,dotted](q9);
\draw[->](q7)edge[swap,dotted](q10);

\node at (-.85,-.6) {$a_1$};
\node at (.2,-.6) {$a_i$};
\node at (.85,-.6) {$a_{\ell}$};
\node at (-2.4,-2.2) {$a_1$};
\node at (-1.3,-2.2) {$a_i$};
\node at (-.55,-2.2) {$a_{\ell}$};

\end{tikzpicture}
\caption{\small The labeled execution tree of MPP~(\ref{eqn:MPP}) on input $\xx$}\label{fig:exe-tree}
\end{minipage}
\hspace{.5cm}
\begin{minipage}[t]{0.45\linewidth}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm,semithick]
\node[state,rectangle](q1){$(1,-1)$};
\node[state,rectangle,white](q3)[below of=q1]{};
\node[state,rectangle](q2)[left of=q3]{$(2,-2)$};
\node[state,rectangle](q4)[right of=q3]{$(1,1)$};

\node[state,rectangle](q6) at (-.6,-2.7) {$(4,4)$};
\node[state,rectangle](q5)[left of=q6]{$(3,-3)$};

\node[state,rectangle,white](q9) at (-2.35,-4.25) {$0$};
\node[state,rectangle,white](q10)[right of=q9]{$2$};

\draw[->](q1)edge[swap](q2);
\draw[->](q1)edge[swap](q4);
\draw[->](q2)edge[swap](q5);
\draw[->](q2)edge[swap](q6);

\draw[->](q5)edge[swap,dotted](q9);
\draw[->](q5)edge[swap,dotted](q10);

\node at (-.75,-.45) {$L$};
\node at (.75,-.45) {$R$};
\node at (-1.7,-1.85) {$L$};
\node at (-0.7,-1.85) {$R$};
\node at (-2.25,-3.3) {$L$};
\node at (-1.3,-3.3) {$R$};
\end{tikzpicture}

\caption{\small The execution tree of MPP~(\ref{eqn:eg-exe-path}) on input $(1,-1)$}\label{fig:exe-path}
\end{minipage}
\end{figure}

To characterize the set of paths in Figure~\ref{fig:exe-tree} starting from root $\xx$, we introduce below some conventional notions on \emph{alphabet} and \emph{strings} for self-containedness.

Let $\Sigma$ be a finite set of symbols, called an \emph{alphabet}. A finite or infinite \emph{string} over $\Sigma$ can be denoted respectively by $\tau=a_1a_2 \cdots a_s$ or $\tau=a_1a_2 \cdots a_s a_{s+1} \cdots$, where $a_i \in \Sigma$ for $i=1,2,\ldots$. A string without any symbol is called the \emph{empty string}, denoted by $\epsilon$. We identify strings with one symbol as the symbol itself. By convention, the set of all finite (including $\epsilon$) and infinite strings are denoted by $\Sigma^*$ and $\Sigma^{\omega}$, respectively.
Let $|\tau|$ denote the length of a string $\tau$. Thus $|\epsilon|=0$, $|\tau|=s$ if $\tau=a_1 a_2 \cdots a_s$, and $|\tau|=\infty$ if $\tau \in \Sigma^{\omega}$. Given $\tau \in \Sigma^* \cup \Sigma^{\omega}$, if there exist $\tau_1 \in \Sigma^*$ and $\tau_2 \in \Sigma^* \cup \Sigma^{\omega}$ such that $\tau = \tau_1 \cdot \tau_2$, where $\cdot$ is the \emph{concatenation} operator on strings, then $\tau_1$ is called a \emph{prefix} of $\tau$; if in addition $|\tau_1|=1$, then $\tau_1$ and $\tau_2$ are called the \emph{head} and \emph{tail} of $\tau$, denoted by $\head(\tau)$ and $\tail(\tau)$ respectively. The set of all prefixes of $\tau$ is denoted by ${\bf Pre}(\tau)$; if $\tau' \in {\bf Pre} (\tau)$ and $\tau' \neq \tau$, then $\tau'$ is called a \emph{proper} prefix of $\tau$.

Let $\Sigma$ be the alphabet consists of all the labels in Figure~\ref{fig:exe-tree}, i.e., $\Sigma=\{a_1,a_2,\ldots,a_{\ell}\}$. Then for any path in Figure~\ref{fig:exe-tree} from root $\xx$ to some node $\xx'$, the labels of the edges along this path generate a finite string $\tau$ over $\Sigma$; furthermore, $\xx'$ results from $\xx$ by the iterated application of the assignments corresponding to the symbols appearing in $\tau$.

Actually, if we define an induced function $\A_{\tau}: \mathbb{R}^n \rightarrow \mathbb{R}^n$ for any $\tau\in \Sigma^*$ as:
\begin{itemize}
\item $\A_{\epsilon}={\bf id}$, i.e., the identity mapping;
\item $\A_{a_i}={\bf A}_i$ for any $a_i\in \Sigma$, where ${\bf A}_i$ is the $i$-th assignment in MPP~(\ref{eqn:MPP});
\item $\A_{\tau} = \A_{\tail(\tau)} \circ \A_{\head(\tau)}$ for $\tau$ with $|\tau|\geq 2$, where $\circ$ denotes the \emph{composition} of functions, i.e., $(f \circ g)(\xx)=f(g(\xx))$ for $f,g: \mathbb{R}^n \rightarrow \mathbb{R}^n$,
\end{itemize}
then the set of paths starting from root $\xx$ of the labeled tree in Figure~\ref{fig:exe-tree} can be represented by a set of strings over $\Sigma$, using the following definition.

%\label{dfn:exe-path}
{\bf Definition 5} (Execution Path)~~{Let $\Sigma$ be what specified above for MPP~(\ref{eqn:MPP}). Then $\tau \in \Sigma^* \cup \Sigma^{\omega}$ is an \emph{execution path} of MPP~(\ref{eqn:MPP}) on input $\xx \in \mathbb{R}^n$ if
\begin{itemize}
\item $\tau=\epsilon$; or
\item $G(\A_{\tau'}(\xx))=0$ for all $\tau' \in {\bf Pre}(\tau), \tau' \neq \tau$ (i.e., $\tau'$ is a proper prefix of $\tau$).
\end{itemize}}

We denote the set of all execution paths of MPP~(\ref{eqn:MPP}) on input $\xx$ by ${\bf Path}(\xx)$. Then there is a one-to-one correspondence between ${\bf Path}(\xx)$ and the set of paths from root $\xx$ in Figure~\ref{fig:exe-tree}: for any execution path $\tau=a_1a_2 \cdots a_s \cdots$ (finite or infinite), there is a path in Figure~\ref{fig:exe-tree} from $\xx$ to a node $\A_{\tau}(\xx)$,  labeled by the symbols $a_1,a_2,\ldots,a_s,\ldots$; conversely, for any path from $\xx$ to some node $\xx'$ in Figure~\ref{fig:exe-tree}, the juxtaposition of the labels along this path gives an execution path in ${\bf Path}(\xx)$.

%\label{eg:exe-path}
{\bf Example 2}~~{Consider the following MPP
\begin{equation}\label{eqn:eg-exe-path}
\while \quad (x+y=0) \quad \left\{
\begin{array}{ll}
& \quad (x,y) := (x+1, y-1); \\
\,|| & \quad (x,y) := (x^2, y^2); \\
\end{array}
\right\}
\enspace .
\end{equation}
If we associate symbols $L,R$ with the first and second assignments of MPP~(\ref{eqn:eg-exe-path}) respectively, it is easy to verify that on input $(1,-1)$, MPP~(\ref{eqn:eg-exe-path}) has an infinite execution path $LLL \cdots$ and finite execution paths $R,LR,LLR$ and so on (see Figure~\ref{fig:exe-path}). }

    \dsee{3.3~~Non-termination Definitions}
    %\label{def:Termin}
    {\bf Definition 6} (Non-termination)~~{An input $\xx \in \mathbb{R}^n$ of MPP~(\ref{eqn:MPP}) is a {\em non-terminating input} if the MPP has an infinite execution path on $\xx$, i.e., ${\bf Path}(\xx) \cap \Sigma^{\omega} \neq \emptyset$; otherwise $\xx$ is a \emph{terminating input}.}

\label{eg:nt}{\bf Example 3}~~{Consider MPP~(\ref{eqn:eg-exe-path}). By Example~2, MPP~(\ref{eqn:eg-exe-path}) has an infinite execution path $LLL \cdots$ on $(1,-1)$. So $(1,-1)$ is a non-terminating input of MPP~(\ref{eqn:eg-exe-path}). }

The set of all non-terminating inputs of MPP~(\ref{eqn:MPP}) is denoted by $\NTI$. Termination analysis of MPPs concerns such problems as
\begin{enumerate}
\item[1)] whether a given MPP terminates on all inputs $\xx$; or alternatively,
\item[2)] detection of non-terminating inputs for a given MPP.
\end{enumerate}
It was proved in [5] that for general MPPs with inequality-typed loop guards, the problem of deciding whether $\NTI$ is an empty set is undecidable. To get some computational results for termination analysis of MPP~(\ref{eqn:MPP}), we propose the following two notions for under/over-approximating non-terminating input set.

%\label{def:SNT}
{\bf Definition 7} (Strong Non-termination)~~{An input $\xx \in \mathbb{R}^n$ of MPP~(\ref{eqn:MPP}) is a \emph{strong} non-terminating input if the MPP has all the infinite strings as its execution paths, i.e., $\Sigma^{\omega} \subseteq {\bf Path}(\xx)$.}

Intuitively, on a strong nonterminating input, the loop guard of MPP~(\ref{eqn:MPP}) is persistently satisfied no matter how many iterations have been executed, or which assignment is selected at each iteration.

%\label{eg:snt}
{\bf Example 4}~~{Consider the following MPP
\begin{equation}\label{eqn:eg-snt}
\while \quad (x^2+1-y=0) \quad \left\{
\begin{array}{ll}
& \quad (x,y) := (x,x^2y); \\
\,|| & \quad (x,y) := (-x,y); \\
\end{array}
\,\right\} \enspace .
\end{equation}
We associate symbols $L,R$ with the two assignments in MPP~(\ref{eqn:eg-snt}) respectively. Figure~\ref{fig:eg-snt} illustrates the execution tree of MPP~(\ref{eqn:eg-snt}) on input $(1,2)$. Note that both $(1,2)$ and $(-1,2)$ satisfy the loop guard. So it can be shown that $(1,2)$ is a strong non-terminating input of MPP~(\ref{eqn:eg-snt}).}

%\label{def:WNT}
{\bf Definition 8} (Weak Non-termination)~~{An input $\xx \in \mathbb{R}^n$ of MPP~(\ref{eqn:MPP}) is a \emph{weak} non-terminating input if for any $k \in \mathbb{N}$, there exists $\tau_k \in\Sigma^*$ such that
\begin{equation}\label{eqn:wnt}
|\tau_k|=k \,\mbox{ and }\, G(\A_{\tau_k}(\xx))=0 \enspace.
\end{equation}}

Intuitively, on a weak nonterminating input $\xx$, we can find $\tau_k$ of any length $k \in \mathbb{N}$, such that when applying the induced function $\A_{\tau_k}$ to $\xx$, the loop guard will be satisfied. However, as the set of such $\tau_k$ is not \emph{prefix-closed}, according to Definition~5, $\tau_k$ is not necessarily an execution path for any $k$. Therefore we call such $\tau_k$ \emph{pseudo execution paths} of MPP~(\ref{eqn:MPP}).

\begin{figure}
\begin{minipage}[t]{0.45\linewidth}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm,semithick]
\node[state,rectangle](q1){$(1,2)$};
\node[state,rectangle,white](q3)[below of=q1]{};
\node[state,rectangle](q2)[left of=q3]{$(1,2)$};
\node[state,rectangle](q4)[right of=q3]{$(-1,2)$};

\node[state,rectangle](q6) at (-.6,-2.5) {$(-1,2)$};
\node[state,rectangle](q5)[left of=q6]{$(1,2)$};
\node[state,rectangle](q7) at (0.7,-2.5) {$(-1,2)$};
\node[state,rectangle](q8)[right of=q7]{$(1,2)$};

\node[state,rectangle,white](q9)[below of=q5]{$(1,2)$};
\node[state,rectangle,white](q10)[below of=q6]{$(-1,2)$};
\node[state,rectangle,white](q11)[below of=q7]{$(-1,2)$};
\node[state,rectangle,white](q12)[below of=q8]{$(1,2)$};

\draw[->](q1)edge[swap](q2);
\draw[->](q1)edge[swap](q4);
\draw[->](q2)edge[swap](q5);
\draw[->](q2)edge[swap](q6);
\draw[->](q4)edge[swap](q7);
\draw[->](q4)edge[swap](q8);

\draw[->](q5)edge[swap,dotted](q9);
\draw[->](q6)edge[swap,dotted](q10);
\draw[->](q7)edge[swap,dotted](q11);
\draw[->](q8)edge[swap,dotted](q12);

\node at (-.75,-.45) {$L$};
\node at (.75,-.45) {$R$};
\node at (-1.7,-1.8) {$L$};
\node at (-0.7,-1.8) {$R$};
\node at (1.75,-1.8) {$R$};
\node at (0.75,-1.8) {$L$};
\end{tikzpicture}
\caption{\small The execution tree of MPP~(\ref{eqn:eg-snt}) on input $(1,2)$}\label{fig:eg-snt}
\end{minipage}
\hspace{.5cm}
\begin{minipage}[t]{0.45\linewidth}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm,semithick]
\node[state,rectangle](q1){$1$};
\node[state,rectangle,white](q3)[below of=q1]{};
\node[state,rectangle](q2)[left of=q3]{$0$};
\node[state,rectangle](q4)[right of=q3]{$2$};

\node[state,rectangle,dotted](q6) at (-.6,-2.5) {$1$};
\node[state,rectangle,dotted](q5)[left of=q6]{$1$};

\node[state,rectangle](q7) at (0.7,-2.5) {$-3$};
\node[state,rectangle](q8)[right of=q7]{$3$};

\node[state,rectangle,white](q11)[below of=q6]{};

\node[state,rectangle,dotted](q9) at (-2.35,-3.85) {$0$};
\node[state,rectangle,dotted](q10)[right of=q9]{$2$};

\node[state,rectangle,white](q12)[below of=q9] {$0$};
\node[state,rectangle,white](q13)[below of=q10]{$2$};

\draw[->](q1)edge[swap](q2);
\draw[->](q1)edge[swap](q4);
\draw[->](q2)edge[swap,dotted](q5);
\draw[->](q2)edge[swap,dotted](q6);
\draw[->](q4)edge[swap](q7);
\draw[->](q4)edge[swap](q8);

\draw[->](q5)edge[swap,dotted](q9);
\draw[->](q5)edge[swap,dotted](q10);
\draw[->](q6)edge[swap,dotted](q11);
\draw[->](q9)edge[swap,dotted](q12);
\draw[->](q10)edge[swap,dotted](q13);

\node at (-.75,-.45) {$L$};
\node at (.75,-.45) {$R$};
\node at (-1.7,-1.8) {$L$};
\node at (-0.7,-1.8) {$R$};
\node at (1.75,-1.8) {$R$};
\node at (0.75,-1.8) {$L$};
\node at (-2.25,-3.1) {$L$};
\node at (-1.3,-3.1) {$R$};
\end{tikzpicture}

\caption{\small The (pseudo) execution paths of MPP~(\ref{eqn:eg-wnt}) on input $x=1$}\label{fig:eg-wnt}
\end{minipage}
\end{figure}

%\label{eg:wnt}
{\bf Example 5}~~{Consider the following MPP
\begin{equation}\label{eqn:eg-wnt}
\while \quad ((x-1)(x-2)=0) \quad \left\{
\begin{array}{ll}
& \quad x := 1-x^2; \\
\,|| & \quad x := x+1; \\
\end{array}
\,\right\} \enspace .
\end{equation}
We associate symbols $L,R$ with the first and second assignments, respectively. Note that the loop guard is satisfied if and only if $x=1$ or $x=2$. Then it is easy to verify that $x=1$ is a weak non-terminating input of MPP~(\ref{eqn:eg-wnt}), by choosing $\tau_k$ as $\epsilon, R, LL, LLR, LLLL, \ldots$ (see Figure~\ref{fig:eg-wnt}).
Note that $x=1$ is actually a terminating input of MPP~(\ref{eqn:eg-wnt}) and the dotted nodes in Figure~\ref{fig:eg-wnt} cannot be reached by real execution. }

Denote the set of all strong non-terminating inputs and weak non-terminating inputs by $\SNTI$ and $\WNTI$, respectively. Then the relationship between the above notions of non-termination can be stated as the following proposition.

%\label{prop:3-termination}
{\bf Proposition 1}~~{\it For MPP~(\ref{eqn:MPP}), the inclusions $\SNTI \subseteq \NTI \subseteq \WNTI$ hold.}

{\it Proof}~~ The first inclusion follows from $\Sigma^{\omega} \subseteq {\bf Path}(\xx) \Longrightarrow \Sigma^{\omega} \cap {\bf Path}(\xx) \neq \emptyset$. Second, for any $\xx \in \NTI$, there exists $\tau \in \Sigma^{\omega}$ satisfying the condition of Definition~5. Then by choosing $\tau_k$ as the prefix of $\tau$ with length $k$, we can see from (\ref{eqn:wnt}) that $\xx \in \WNTI$. Thus $\NTI$ is a subset of $\WNTI$. \rulex

{\bf Remark 1}~~{Both inclusions in Proposition~1 may be proper: from Examples~2 and 3 we can see that $(1,-1) \in \NTI$, but $(1,-1) \notin \SNTI$ for MPP~(\ref{eqn:eg-exe-path}); Example~5 shows that $1 \in \WNTI$, but $1 \notin \NTI$ for MPP~(\ref{eqn:eg-wnt}). However, if MPP~(\ref{eqn:MPP}) has a single path, we can conclude that $\SNTI=\NTI=\WNTI$.
}

According to Proposition~1, strong/weak non-termination can be used in under/over approximation analysis of non-termination: any element in $\SNTI$ is a witness to the non-termination of MPP~(\ref{eqn:MPP}), and conversely the emptiness of $\WNTI$ implies that MPP~(\ref{eqn:MPP}) terminates on all inputs.

\dse{4~~The Computation of SNTI}
In this section, based on polynomial ideal theory, we will reduce $\SNTI$ of any MPP~(\ref{eqn:MPP}) to the real variety of a polynomial ideal $\I$; furthermore, we can always compute a finite basis of $\I$, thus giving a complete characterization of $\SNTI$. This enables us to check the emptiness of $\SNTI$ for any MPP~(\ref{eqn:MPP}), or test whether $\xx \in \SNTI$ for a given $\xx \in \mathbb{R}^n$.

\dsee{4.1~~Iteration Trees}
During the execution of MPPs, the assignments ${\bf A}_i$ in the loop body are applied to program states $\xx$. On the other hand, if we focus on the loop guard test of each iteration, the assignments can also be viewed as applications to the loop guard $G(\xx)=0$, which produce a series of polynomial equations, or equivalently, polynomials. Using these polynomials as nodes, we can construct an \emph{iteration tree} (see Figure~\ref{fig:it-tree}) which is very useful in the computation of non-terminating inputs.

%\label{dfn:it-tree}
{\bf Definition 9} (Iteration Tree)~~{An \emph{iteration tree} of MPP~(\ref{eqn:MPP}) is defined inductively as:
\begin{itemize}
\item the \emph{root} is $G(\xx)$, i.e., the polynomial in the loop guard of MPP~(\ref{eqn:MPP});
\item for any node $G({\bf p}(\xx))$ in the tree, where ${\bf p}(\xx): \mathbb{R}^n \rightarrow \mathbb{R}^n$ is a vector function, it has $\ell$ directly successive nodes $G({\bf A}_1({\bf p}(\xx))),G({\bf A}_2({\bf p}(\xx))),\ldots,G({\bf A}_{\ell} ({\bf p}(\xx)))$; and there is a \emph{directed edge} connecting $G({\bf p}(\xx))$ and $G({\bf A}_i ({\bf p}(\xx)))$, labeled by $a_i$, for any $1 \leq i \leq \ell$.
\end{itemize}}

\begin{figure}
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.6cm,semithick]
\node[state,rectangle](q1){$G(\xx)$};
\node[state,rectangle](q3)[below of=q1]{$\cdots$};
\node[state,rectangle](q2)[left of=q3]{$G({\bf A}_1(\xx))$};
\node[state,rectangle](q4)[right of=q3]{$G({\bf A}_{\ell}(\xx))$};
\node[state,rectangle](q6)[below of=q2]{$\cdots$};
\node[state,rectangle](q5)[left of=q6]{$G({\bf A}_1({\bf A}_1(\xx)))$};
\node[state,rectangle](q7)[right of=q6]{$G({\bf A}_{\ell}({\bf A}_1(\xx)))$};

\node[state,rectangle,white](q8)[below of=q4]{};
\node[state,rectangle,white](q9)[below of=q5]{};
\node[state,rectangle,white](q10)[below of=q7]{};

\draw[->](q1)edge[swap](q2); \draw[->](q1)edge[swap](q3);
\draw[->](q1)edge[swap](q4); \draw[->](q2)edge[swap](q5);
\draw[->](q2)edge[swap](q6); \draw[->](q2)edge[swap](q7);
\draw[->](q4)edge[swap,dotted](q8);
\draw[->](q5)edge[swap,dotted](q9);
\draw[->](q7)edge[swap,dotted](q10);

\node at (-.95,-.7) {$a_1$};
\node at (.2,-.7) {$a_i$};
\node at (.95,-.7) {$a_{\ell}$};
\node at (-2.55,-2.3) {$a_1$};
\node at (-1.4,-2.3) {$a_i$};
\node at (-.65,-2.3) {$a_{\ell}$};
\end{tikzpicture}
\end{center}
\caption{\small The iteration tree of MPP~(\ref{eqn:MPP})}\label{fig:it-tree}
\end{figure}

{\bf Remark 2}~~{Iteration trees have the following features compared with execution trees:
\begin{itemize}
\item each node in an iteration tree is a polynomial in $\mathbb{Q}[\xx]$, rather than an element in $\mathbb{R}^n$;
\item iteration trees are infinite trees with no leaf node, and each node has exactly $\ell$ children;
\item an iteration tree is constructed statically without dynamically executing an MPP to get the trace of program state variables.
\end{itemize}}

\dsee{4.2~~Computing SNTI as Real Varieties}
Intuitively, a strong non-terminating input $\xx \in \mathbb{R}^n$ of an MPP will persistently satisfy the loop guard $G(\xx)=0$, and thus must be a common real root of all the polynomials in the iteration tree of the MPP. To see this, it is convenient to consider the infinitely many polynomials in an iteration tree level by level, rather than by paths.

%\label{lem:snt-1}
{\bf Lemma 1}~~{\[
\SNTI=\V\left( \bigcup_{k \geq 0} \bigcup_{|\tau|=k} \{G(\A_{\tau}(\xx))\} \right) \cap \mathbb{R}^n \enspace .
\]}

{\it Proof}~~ By Definition~7, $\xx \in \SNTI$ if and only if for any $\tau \in \Sigma^{\omega}$, and any $\tau' \in {\bf Pre}(\tau)$, $G(\A_{\tau'}(\xx))=0$, i.e.,
\[
\SNTI=\V\left( \bigcup_{\tau \in \Sigma^{\omega}} \bigcup_{\tau' \in {\bf Pre}(\tau)} \{G(\A_{\tau'}(\xx))\} \right) \cap \mathbb{R}^n \enspace .
\]
Hence this lemma follows immediately from the fact
\[
\bigcup_{\tau \in \Sigma^{\omega}} \bigcup_{\tau' \in {\bf Pre}(\tau)} \{\tau'\} = \bigcup_{k \geq 0} \bigcup_{|\tau|=k} \{\tau\} \enspace .
\]
\rulex

To employ the correspondence between ideals and varieties and the nice properties of polynomial ideals, let
\begin{equation}\label{eqn:ideal-snt}
\I_k \,\,\define\,\left\langle \bigcup_{|\tau| \leq k} \{G(\A_{\tau}(\xx))\} \right\rangle \qquad (k=0,1,2,\ldots) \enspace .
\end{equation}
That is, $\I_k$ is the ideal generated by all the polynomials from the top $k+1$ levels of the iteration tree. Then we have

%\label{lem:snt-2}
{\bf Lemma 2}~~{\[
\SNTI=\V\left( \bigcup_{k \geq 0} \I_k \right) \cap \mathbb{R}^n \enspace .
\]}

{\it Proof}~~ By (\ref{eqn:ideal-snt}) it is easy to show that
\[
\bigcup_{k \geq 0}\I_k = \bigcup_{k \geq 0} \left\langle \bigcup_{|\tau| \leq k} \{G(\A_{\tau}(\xx))\} \right\rangle = \left\langle \bigcup_{k \geq 0} \bigcup_{|\tau| \leq k} \{G(\A_{\tau}(\xx))\} \right\rangle  = \left\langle \bigcup_{k \geq 0} \bigcup_{|\tau|=k} \{G(\A_{\tau}(\xx))\} \right\rangle \enspace .
\]
Hence this lemma follows from Lemma~1. \rulex

Lemma~2 can be further simplified to

%\label{lem:snt-3}
{\bf Lemma 3}~~{\it There exists an integer $N \in \mathbb{N}$ such that
\[
\SNTI = \V(\I_N) \cap \mathbb{R}^n \enspace .
\]}

{\it Proof}~~ Note that $\I_0 \subseteq \I_1 \subseteq \I_2 \subseteq \cdots$ forms an ascending chain of ideals. Hence this lemma follows from Theorem~2 and Lemma~2. \rulex

Now we have reduced $\SNTI$ of MPP~(\ref{eqn:MPP}) to the real variety of a polynomial ideal. The following theorem shows that the integer $N$ in Lemma~3 is actually computable.

%\label{thm:fixed-snt}
{\bf Theorem 3} (Fixed Point Theorem)~~{\it If $\I_m=\I_{m+1}$, then $\I_m=\I_k$ for any $k \geq m+1$.}

{\it Proof}~~ We prove this by induction on $k$ for $k \geq m+1$.

Basis: $\I_m=\I_{m+1}$, which means $G(\A_{\tau}(\xx)) \in \I_m$ for any $\tau$ with $|\tau| \leq m+1$.

Induction: Assume that $\I_m = \I_k$ for some $k \geq m+1$, which means for any $\tau$ with $|\tau|=k$, there exist $g_{\sigma}(\xx) \in \mathbb{Q}[\xx]$, for each $\sigma \in \Sigma^*$ with $|\sigma| \leq m$, such that
\[
G(\A_{\tau}(\xx))=\sum_{|\sigma| \leq m} g_{\sigma}(\xx) G(\A_{\sigma}(\xx)) \enspace .
\]
We will show that $\I_m = \I_{k+1}$. Note that for any $\tau$ with $|\tau|=k+1$, we have
\[
\begin{array}{lll}
G(\A_{\tau}(\xx)) & = G(\A_{\tail(\tau)}(\A_{\head(\tau)}(\xx))) & \quad(|\tail(\tau)|=k) \\
& = \sum\limits_{|\sigma|\leq m} g_{\sigma}(\A_{\head(\tau)}(\xx)) G(\A_{\sigma}(\A_{\head(\tau)}(\xx))) & \quad \mbox{(by induction hypothesis)} \\
& = \sum\limits_{|\sigma|\leq m} g_{\sigma}(\A_{\head(\tau)}(\xx)) G(\A_{\head(\tau)\cdot\sigma}(\xx)) & \quad (|\head(\tau) \cdot \sigma| \leq m+1) \\
& \in \,\I_m & \quad (\mbox{by induction basis}) \enspace .
\end{array}
\]
\rulex

By Theorem~3, $N$ can be computed as the first integer $k$ satisfying $\I_k=\I_{k+1}$. Now the main result on $\SNTI$ computation can be stated as:

%\label{thm:main-snt}
{\bf Theorem 4}~~{\it For MPP~(\ref{eqn:MPP}), an integer $N \in \mathbb{N}$ can be computed such that
\[
\SNTI=\V(\I_N) \cap \mathbb{R}^n \enspace .
\]}

{\it Proof}~~ It follows immediately from Lemma~3 and Theorem~3. \rulex

An abstract algorithm for computing $\SNTI$ can be given as:
\begin{algorithm}\label{alg:snt}
$k \leftarrow 0$\;
\While{$\I_{k} \neq \I_{k+1}$}
    {$k \leftarrow k+1$\;}
    {\KwRet{$\V(\I_k) \cap \mathbb{R}^n$}\;}
\caption{The Computation of $\SNTI$ for MPP~(\ref{eqn:MPP})}
\end{algorithm}

%\label{eg:computation-snt}
{\bf Example 6}~~{We show the application of Algorithm~\ref{alg:snt} to three aforementioned MPPs.
\begin{enumerate}
\item[1)] For MPP~(\ref{eqn:eg-exe-path}), we get\footnote{For the computation of Gr\"obner bases, we are assuming the \emph{pure lexicographic order} $x \succ y$.}
    \[
    \I_0=\langle x+y \rangle \subsetneq \I_1=\langle y^2, x+y \rangle \subsetneq \I_2=\langle 1 \rangle = \I_3 \enspace .
    \]
    So $\SNTI = \V(\langle 1 \rangle) \cap \mathbb{R}^2 = \emptyset$.
\item[2)] For MPP~(\ref{eqn:eg-snt}), we get
    \[
    \I_0=\langle x^2+1-y \rangle \subsetneq \I_1=\langle y^2-2y,x^2+1-y \rangle = \I_2 \enspace .
    \]
    So $\SNTI=\V(\langle y^2-2y,x^2+1-y \rangle) \cap \mathbb{R}^2=\{(1,2),(-1,2)\}$.
\item[3)] For MPP~(\ref{eqn:eg-wnt}), we get
    \[
    \I_0=\langle x^2-3x+2 \rangle \subsetneq \I_1=\langle 1 \rangle = \I_2 \enspace .
    \]
    So $\SNTI=\V(\langle1\rangle) \cap \mathbb{R}=\emptyset$.
\end{enumerate}
}

\dse{5~~The Computation of WNTI}
In this section, we will first reduce $\WNTI$ of MPP~(\ref{eqn:MPP}) to the real variety of a certain polynomial ideal $\J$. We then provide a \emph{sufficient} criterion under which a finite basis of $\J$ can be computed, and thus give a complete characterization of $\WNTI$ under such a criterion.

\dsee{5.1~~Identifying WNTI as Real Varieties}
Intuitively, a weak nonterminating input is a real root of at least one of the polynomials at every level of the iteration tree in Figure~\ref{fig:it-tree}, or equivalently, a real root of the \emph{product} of the polynomials (called a \emph{product polynomial}) at each level.

%\label{lem:wnt-1}
{\bf Lemma 4}
\[
\WNTI=\V\left(\bigcup_{j \geq 0} \left\{\prod_{|\tau|=j} G(\A_{\tau}(\xx)) \right\} \right) \cap \mathbb{R}^n \enspace .
\]

{\it Proof}~~ It is a direct translation of (\ref{eqn:wnt}) in Definition~8. \rulex

To adopt the language of polynomial ideals, we consider the ideals generated by the \emph{product polynomials} from the top $k+1$ levels of the iteration tree:
\begin{equation}\label{eqn:ideal-wnt}
\J_k\,\,\define\,\left\langle \bigcup_{j \leq k} \left\{ \prod_{|\tau|=j} G(\A_{\tau}(\xx)) \right\} \right\rangle \qquad (k=0,1,2,\ldots) \enspace .
\end{equation}
Then we have

%\label{lem:wnt-2}
{\bf Lemma 5}~~{\[
\WNTI=\V\left(\bigcup_{k \geq 0} \J_k \right) \cap \mathbb{R}^n \enspace .
\]}

{\it Proof}~~ By (\ref{eqn:ideal-wnt}) it is easy to show that
\[
\begin{array}{ll}
\bigcup\limits_{k \geq 0} \J_k & = \bigcup\limits_{k \geq 0} \left\langle \bigcup\limits_{j \leq k} \left\{ \prod\limits_{|\tau|=j} G(\A_{\tau}(\xx)) \right\} \right\rangle = \left\langle \bigcup\limits_{k \geq 0} \bigcup\limits_{j \leq k} \left\{ \prod\limits_{|\tau|=j} G(\A_{\tau}(\xx)) \right\} \right\rangle \\
& = \left\langle \bigcup\limits_{j \geq 0} \left\{ \prod\limits_{|\tau|=j} G(\A_{\tau}(\xx)) \right\} \right\rangle \enspace .
\end{array}
\]
Hence this lemma follows from Lemma~4. \rulex

Lemma~5 can be further simplified to

%\label{lem:wnt-3}
{\bf Lemma 6}~~{\it There exists an integer $N \in \mathbb{N}$ such that
\[
\WNTI=\V(\J_N) \cap \mathbb{R}^n \enspace .
\]}

{\it Proof}~~ Note that $\J_0 \subseteq \J_1 \subseteq \J_2 \subseteq \cdots$ forms an ascending chain of ideals. Hence this lemma follows from Theorem~2 and Lemma~5. \rulex

Now we have proved that $\WNTI$ of MPP~(\ref{eqn:MPP}) is a real variety, a result analogous to what we have established for $\SNTI$ (Lemma~3). However, we do not have a criterion like Theorem~3 for checking the fixed point of the chain of ideals $\J_k$. Nevertheless, a \emph{sufficient} criterion will be given under some conditions in the coming subsection.


\dsee{5.2~~A Sufficient Criterion for Computability of WNTI}
Let \begin{equation}\label{eqn:ideal-wnt-trunc}
\hat{\J}_{m,k}\,\,\define\,\left\langle \bigcup_{m \leq j \leq k}\left\{ \prod_{|\tau|=j} G(\A_{\tau}(\xx)) \right\} \right\rangle \qquad (0 \leq m \leq k) \enspace .
\end{equation}
Intuitively, $\hat{\J}_{m,k}$ is the ideal generated by the \emph{product polynomials} from levels $m$ to $k$ in the iteration tree in Figure~\ref{fig:it-tree}.

For the ideals $\hat{\J}_{m,k}$ and $\J_k$ defined in (\ref{eqn:ideal-wnt-trunc}) and (\ref{eqn:ideal-wnt}) respectively, we have $\hat{\J}_{m,k} \subseteq \J_k$ for any $k \geq m \geq 0$, in particular, $\hat{\J}_{0,k}=\J_k$ for any $k \geq 0$. Besides, noticing that for any $m \in \mathbb{N}$, the sequence of $\hat{\J}_{m,k}$ for $k=m,m+1,m+2,\ldots$ forms an ascending chain of ideals, we can actually prove

%\label{lem:wnt-4}
{\bf Lemma 7}~~{\it For any $M,N \in \mathbb{N}$ with $M \leq N$, if $\hat{\J}_{M,N}$ is the fixed point of the chain of ideals formed by $\{\hat{\J}_{M,k}\}|_{k \geq M}$, then $\J_N$ is the fixed point of the chain of ideals formed by $\{\J_k\}|_{k \geq 0}$.}

{\it Proof}~~ It is sufficient to prove that for any $k> N$, $\hat{\J}_{M,N}=\hat{\J}_{M,k}$ implies $\J_N=\J_k$.

Note that $\hat{\J}_{M,N}=\hat{\J}_{M,k}$ implies
\[
\forall j. \,N<j \leq k: \quad \prod_{|\tau|=j} G(\A_{\tau}(\xx))\,\,\in \,\,\hat{\J}_{M,N}\,\,\subseteq\,\, \J_N  \enspace ,
\]
which means the set of generators of $\J_k$ are all elements of $\J_N$. Thus $\J_N=\J_k$. \rulex

As mentioned above, for any $M \in \mathbb{N}$, how to compute the fixed point of the chain of ideals $\J_{M,k}$ for $k \geq M$ is an open problem in general. However, a sufficient criterion can be given as follows, which can be seen as a weak version of Theorem~3.

%\label{thm:fixed-wnt}
{\bf Theorem 5} (Weak Fixed Point Theorem)~~{\it If there exist $M,N \in \mathbb{N}$, $M\leq N$, such that $\hat{\J}_{M,N}$ is a principal ideal, i.e., $\hat{\J}_{M,N}=\langle H(\xx)\rangle$ for some $H(\xx) \in \mathbb{Q}[\xx]$, and in addition, $H(\xx)$ satisfies
\begin{equation}\label{eqn:principal-one-iteration}
\prod_{|\tau|=1} H(\A_{\tau}(\xx)) \ \in \ \langle H(\xx) \rangle \enspace ,
\end{equation}
then $\J_N=\J_k$ for all $k \geq N$.}

{\it Proof}~~ By Lemma~7, it suffices to prove that $\hat{\J}_{M,N} = \hat{\J}_{M,k}$ for all $k \geq N$. The proof will proceed by induction on $k$ for $k \geq N$.

Suppose $\hat{\J}_{M,N}=\langle H(\xx) \rangle= \hat{\J}_{M,k}$ for some $k \geq N$. Then there exists $g(\xx) \in \mathbb{Q}[\xx]$ such that $\prod_{|\tau|=k} G(\A_{\tau}(\xx)) = g(\xx)H(\xx)$.
\[
\begin{array}{lll}
\prod\limits_{|\tau|=k+1} G(\A_{\tau}(\xx)) & = \prod\limits_{|\tau_1|=1}\, \prod\limits_{|\tau_2|=k} G(\A_{\tau_2}(\A_{\tau_1}(\xx))) \\
& = \prod\limits_{|\tau_1|=1} g(\A_{\tau_1}(\xx)) H(\A_{\tau_1}(\xx)) & \qquad \mbox{(by induction hypothesis)} \\
& = \left[ \prod\limits_{|\tau_1|=1} g(\A_{\tau_1}(\xx)) \right] \, \left[ \prod\limits_{|\tau_1|=1} H(\A_{\tau_1}(\xx)) \right] \\
& \in \langle H(\xx) \rangle & \qquad \mbox{(by the requirement~(\ref{eqn:principal-one-iteration}))} \enspace .
\end{array}
\]
Hence we get $\hat{\J}_{M,N}= \hat{\J}_{M,k+1}$, which completes the proof by induction. \rulex

Now the main result on $\WNTI$ computation can be stated as follows, which is analogous to Theorem~4.

%\label{thm:main-wnt}
{\bf Theorem 6}~~{\it For MPP~(\ref{eqn:MPP}), if the requirements in Theorem~5 are satisfied, an integer $N$ can be computed such that
\[
\WNTI=\V(\J_N) \cap \mathbb{R}^n \enspace .
\]}

{\it Proof}~~ It follows immediately from Lemma~6 and Theorem~5. \rulex

\dsee{5.3~~Applying Theorem~6 to Compute WNTI}
Based on Theorem~6, we present an abstract algorithm (Algorithm \ref{alg:wnt}) for computing $\WNTI$ of MPP~(\ref{eqn:MPP}).
\begin{algorithm}\label{alg:wnt}
$m \leftarrow 0$\;
\While{$m\leq M$}{
    $k \leftarrow m$\;
    \While{$\hat{\J}_{m,k} \neq \hat{\J}_{m,k+1}$}
    {$k \leftarrow k+1$\;}
    \eIf{$\hat{\J}_{m,k}=\langle H(\xx)\rangle$ \rm{and} $H(\xx)$ \rm{satisfies (\ref{eqn:principal-one-iteration})}}
    {\KwRet{$\V(\J_k) \cap \mathbb{R}^n$}\;}
    {$m \leftarrow m+1$\;}}
\KwRet{\sf unknown};
\caption{The Computation of $\WNTI$ for MPP~(\ref{eqn:MPP})}
\end{algorithm}

The meaning of Algorithm~\ref{alg:wnt} is: for each $m \in \mathbb{N}$, we compute $\hat{\J}_{m,k}$ for $k=m,m+1,m+2,\ldots$ until $\hat{\J}_{m,k}=\hat{\J}_{m,k+1}$ (lines 3--5)\footnote{By Theorem~2, this iteration must terminate.}; then we test whether $\hat{\J}_{m,k}$ is a principal ideal and the single generator satisfies (\ref{eqn:principal-one-iteration}) (line 6); if the test succeeds, by Theorem~6 we get the $\WNTI$ (line 7); otherwise, we increase $m$ by 1 (line 9) and continue the computation; the number $M$ in line 2 is a prescribed bound on $m$ to ensure termination of the whole algorithm, and when $m$ exceeds $M$, Algorithm~\ref{alg:wnt} terminates with the answer {\sf unknown} (line 10).

%\label{eg:computation-wnt}
{\bf Example 7}~~{We use Algorithm~\ref{alg:wnt} to compute the $\WNTI$ of several MPPs.
\begin{enumerate}
\item[1)] For MPP~(\ref{eqn:eg-exe-path}), we get $\hat{\J}_{0,0}= \langle x+y \rangle = \hat{\J}_{0,1}$, in which $x+y$ satisfies (\ref{eqn:principal-one-iteration}). So $\WNTI = \V(\J_0) \cap \mathbb{R}^2 = \V(\langle x+y \rangle) \cap \mathbb{R}^2$.
\item[2)] For MPP~(\ref{eqn:eg-snt}), we get $\hat{\J}_{0,0} = \langle x^2+1-y \rangle = \hat{\J}_{0,1}$, in which $x^2+1-y$ satisfies (\ref{eqn:principal-one-iteration}). So $\WNTI = \V(\J_0) \cap \mathbb{R}^2 = \V(\langle x^2+1-y \rangle) \cap \mathbb{R}^2$.
\item[3)] For MPP~(\ref{eqn:eg-wnt}), we get
     \[
     \hat{\J}_{1,1} = \langle x^4+x^6-x^3-x^5 \rangle \subsetneq \hat{\J}_{1,2} = \langle x^4-x^3 \rangle = \hat{\J}_{1,3} \enspace ,
     \]
     in which $x^4-x^3$ satisfies (\ref{eqn:principal-one-iteration}). So $\WNTI = \V(\J_2) \cap \mathbb{R} = \V(\langle x-1 \rangle) \cap \mathbb{R} = \{1\}$.
\item[4)] Consider the following MPP
    \begin{equation}\label{eqn:eg-wnt-empty}
    \while \quad (x-y^2=0) \quad \left\{
    \begin{array}{ll}
    & \quad (x,y) := (x+3,y+1); \\
    || & \quad (x,y) := (1,0); \\
    \end{array}
    \right\} \enspace .
    \end{equation}
    We can get
    \[
    \hat{\J}_{0,0} = \langle x-y^2 \rangle \subsetneq \hat{\J}_{0,1} = \langle y-1,x-1 \rangle \subsetneq \hat{\J}_{0,2} = \langle 1 \rangle = \hat{\J}_{0,3} \enspace .
    \]
    So $\WNTI = \V(\J_2) \cap \mathbb{R}^2 = \V(\langle 1 \rangle) \cap \mathbb{R}^2 = \emptyset$, which further implies $\NTI=\SNTI=\emptyset$.
\end{enumerate}
}

The results of Examples~6 and 7 can be summarized in Table~1.
\begin{table}
\begin{center}
{\small{\bf Table 1}~  A summary of the computation of non-terminating inputs}\vskip3mm
\begin{tabular}{|c|c|c|c|c|}
  \hline
  MPP & (\ref{eqn:eg-exe-path}) & (\ref{eqn:eg-snt}) & (\ref{eqn:eg-wnt}) & (\ref{eqn:eg-wnt-empty}) \\
  \hline
  $\SNTI$ & $\emptyset$ & $\{(1,2),\,(-1,2)\}$ & $\emptyset$ & $\emptyset$ \\
  $\NTI$ & ? & $\supseteq \{(1,2),\,(-1,2)\} $ & ? & $\emptyset$ \\
  $\WNTI$ & $\V(\langle x+y\rangle) \cap \mathbb{R}^2$ & $\V(\langle x^2+1-y \rangle ) \cap \mathbb{R}^2$ & $\{1\}$ & $\emptyset$ \\
  \hline
\end{tabular}
\end{center}
\vskip-4mm
\end{table}

We explain a bit about the row corresponding to $\NTI$ in Table~1. For MPP~(\ref{eqn:eg-snt}), it can be inferred that $\NTI$ is a superset of $\{(1,2),\,(-1,2)\}$ and must be nonempty. For MPP~(\ref{eqn:eg-wnt-empty}), the emptiness of $\WNTI$ implies the emptiness of $\NTI$. For MPPs~(\ref{eqn:eg-exe-path}) and (\ref{eqn:eg-wnt}), we cannot infer any information from the $\SNTI$/$\WNTI$-approximations and therefore the $\NTI$ are marked with ``?''. Actually from the analysis of Examples~4 and 5 we have known that $(1,-1)$ is in the $\NTI$ of MPP~(\ref{eqn:eg-exe-path}), while the $\NTI$ of MPP~(\ref{eqn:eg-wnt}) is empty.

\dse{6~~Conclusions}
In this paper, we studied the detection of non-terminating inputs over $\mathbb{R}$ for multi-path polynomial programs with equational loop guards (MPP~(\ref{eqn:MPP})). We first defined on MPP the notions of non-terminating inputs ($\NTI$) as well as its under/over-approximation, i.e., strong/weak non-terminating inputs ($\SNTI$/$\WNTI$). Then based on the well-known theory of polynomial ideals, we presented a complete approach for computing $\SNTI$, and a sound but incomplete approach for computing $\WNTI$, both as the real variety of a certain polynomial ideal. Once the $\SNTI$/$\WNTI$ are computed, useful information on $\NTI$ can be inferred.

We have experimented with the proposed algorithms on several simple examples, by interactively calling existing functions in the {\sc Maple} environment. We did these experiments mainly with the purpose of testing and demonstrating proposed algorithms. A fully automated tool with applications to real programs is not provided, due to the high complexity of our approach: the polynomial ideal membership problem is \emph{exponential space complete} in the size of the problem instance [30], and the computation of Gr\"obner basis has even higher worst case complexity; besides, for MPPs with more than one paths, the sizes of ideals $\I_k$ or $\J_k$ in our algorithm grow exponentially with $k$, which could be very large when the fixed point is reached. An estimation of how large $k$ could eventually be is required for a more precise complexity analysis.

There are two theoretical problems left open in this paper:
\begin{enumerate}
\item[1)] Can we drop the restrictive assumption on $\WNTI$ computation and give a complete algorithm for computing $\WNTI$?
\item[2)] Is $\NTI$ reducible to the real variety of a polynomial ideal? If so, how can this variety be computed (at least under some restrictions)?
\end{enumerate}
A negative conjecture could be that a complete description of $\WNTI$ or $\NTI$ is not computable for MPP~(\ref{eqn:MPP}) in general. We are interested in answering these questions in future.

\paragraph{Acknowledgements.} We thank Professors Chaochen Zhou, Lu Yang, Zhibin Li, Bican Xia, Mingsheng Wang and Dingkang Wang for their beneficial discussions on our work. We also thank anonymous reviewers for their valuable comments on the revision of this paper.



%*************************************************************************************************************
% There should not have extra spaces between paragraphs. The first sentence of each paragraph should be indented.

%*************************************************************************************************************
% The tables and figures should be numbered, their contents and captions should be defined by small size, and the captions
% should be written like "{\bf Table 1}~~The caption"


%*************************************************************************************************************
% Theorems, Corollaries, Propositions, and Lemmas should be typed as (take Theorem for example):
%{\bf Theorem 1}~~{\it The content}
%
%{\it Proof}~~ The proof.
% \rulex %The end mark of the proof.

%{\bf Theorem 1}~~{\it }
%
%{\it Proof}~~ \rulex

%*************************************************************************************************************
% Remarks, Definitions, Assumptions, and Examples should be typed as (take Definition for example):
% {\bf Definition 1}~~{The content}
%*************************************************************************************************************

%{\bf Definition 1}~~{ }

%*************************************************************************************************************
% If the formulae are numbered, the numbers should look like "(1), (2), ..." but not "(1.1) (1.2)...";
% The formulae should be aligned.
%*************************************************************************************************************



%*************************************************************************************************************
% References:
%
% References should be cited in the text with numerals in square brackets, e.g. [3]. All references should appear
% and be numbered in a separate bibliography at the end of the paper, e.g.,
%
% Article:
% \rf{1}{W. T. Wu, A mechanization method of geometry and its applications, distances, areas, and volumes, {\it J. of Systems Science and
%  Mathematical Sciences} (in Chinese), 1986, {\bf 6}(3): 204--216.}
% Book:
% \rf{2}{H. F. Chen and L. Guo, {\bf Identification and Stochastic Adaptive Control}, Birkhauser, Boston, 1991.}
% Proceeding:
% \rf{3}{S. L. Liu, S. Y. Wang, and K. K. Lai, Multiple criteria decision making models for competitive bidding, in {\it New Frontiers of
% Decision Making for the Information Technology Era} (ed. by Y. Shi and M. Zeleny), World Scientific, Singapore, 2000, 349--372.}
%
%*************************************************************************************************************

\rfne

\rf{1}{Byron Cook, Andreas Podelski, and Andrey Rybalchenko.
\newblock Proving program termination.
\newblock {\em Communications of the ACM}, 54(5):88--98, 2011.}

\rf{2}{L.~Yang, C.~Zhou, N.~Zhan, and B.~Xia.
\newblock Recent advances in program verification through computer algebra.
\newblock {\em Frontiers of Computer Science in China}, 4(1):1--16, 2010.}

\rf{3}{Alan~M. Turing.
\newblock On computable numbers, with an application to the
  {E}ntscheidungsproblem.
\newblock {\em Proceedings of the London Mathematical Society}, 42(2):230--265,
  1936.}

\rf{4}{A.~Tiwari.
\newblock Termination of linear programs.
\newblock In R.~Alur and D.~A. Peled, editors, {\em Proc. of CAV 2004}, LNCS
  3114, pages 70--82, Berlin, 2004. Springer.}

\rf{5}{A.~R. Bradley, Z.~Manna, and H.~B. Sipma.
\newblock Termination of polynomial programs.
\newblock In R.~Cousot, editor, {\em Proc. of VMCAI 2005}, LNCS 3385, pages
  113--129, Berlin, 2005. Springer.}

\rf{6}{M.~Braverman.
\newblock Termination of integer linear programs.
\newblock In T.~Ball and R.~B. Jones, editors, {\em Proc. of CAV 2006}, LNCS
  4144, pages 372--385, Berlin, 2006. Springer.}

\rf{7}{William~R. Harris, Akash Lal, Aditya~V. Nori, and Sriram~K. Rajamani.
\newblock Alternation for termination.
\newblock In Radhia Cousot and Matthieu Martel, editors, {\em Proc. of SAS
  2010}, LNCS 6337, pages 304--319, Berlin, 2010. Springer.}

\rf{8}{M.~A. Col\'{o}n and H.~B. Sipma.
\newblock Synthesis of linear ranking functions.
\newblock In Tiziana Margaria and Yi~Wang, editors, {\em Proc. of TACAS 2001},
  LNCS 2031, pages 67--81, Berlin, 2001. Springer.}

\rf{9}{A.~Podelski and A.~Rybalchenko.
\newblock A complete method for the synthesis of linear ranking functions.
\newblock In B.~Steffen and G.~Levi, editors, {\em Proc. of VMCAI 2004}, LNCS
  2937, pages 239--251, Berlin, 2004. Springer.}

\rf{10}{Bican Xia and Zhihai Zhang.
\newblock Termination of linear programs with nonlinear constraints.
\newblock {\em Journal of Symbolic Computation}, 45(11):1234--1249, 2010.}

\rf{11}{Bican Xia, Lu~Yang, Naijun Zhan, and Zhihai Zhang.
\newblock Symbolic decision procedure for termination of linear programs.
\newblock {\em Formal Aspects of Computing}, 23(2):171--190, 2011.}

\rf{12}{Ming Xu, Liangyu Chen, Zhenbing Zeng, and Zhi-Bin Li.
\newblock Termination analysis of linear loops.
\newblock {\em International Journal of Foundations of Computer Science},
  21(6):1005--1019, 2010.
}

\rf{13}{Ming Xu and Zhi-Bin Li.
\newblock Symbolic termination analysis of solvable loops.
\newblock {\em Journal of Symbolic Computation}, 50:28--49, 2013.}

\rf{14}{Byron Cook, Sumit Gulwani, Tal Lev-Ami, Andrey Rybalchenko, and Mooly Sagiv.
\newblock Proving conditional termination.
\newblock In A.~Gupta and S.~Malik, editors, {\em Proc. of CAV 2008}, LNCS
  5123, pages 328--340, Berlin, 2008. Springer.}

\rf{15}{S.~Sankaranarayanan, H.~B. Sipma, and Z.~Manna.
\newblock Non-linear loop invariant generation using {Gr\"{o}bner} bases.
\newblock In Neil~D. Jones and Xavier Leroy, editors, {\em Proc. of POPL 2004},
  pages 318--329, New York, 2004. ACM Press.}

\rf{16}{M.~M{\"{u}}ller-Olm and H.~Seidl.
\newblock Computing polynomial program invariants.
\newblock {\em Information Processing Letters}, 91(5):233--244, 2004.}

\rf{17}{D.~Kapur.
\newblock A quantifier-elimination based heuristic for automatically generating
  inductive assertions for programs.
\newblock {\em Journal of Systems Science and Complexity}, 19(3):307--330,
  2006.}

\rf{18}{E.~Rodr\'{\i}guez-Carbonell and D.~Kapur.
\newblock Generating all polynomial invariants in simple loops.
\newblock {\em Journal of Symbolic Computation}, 42(4):443--476, 2007.}

\rf{19}{Laura Kov\'{a}cs.
\newblock Reasoning algebraically about {P}-solvable loops.
\newblock In C.~R. Ramakrishnan and Jakob Rehof, editors, {\em Proc. of TACAS
  2008}, LNCS 4963, pages 249--264, Berlin, 2008. Springer.}

\rf{20}{Yinghua Chen, Bican Xia, Lu~Yang, Naijun Zhan, and Chaochen Zhou.
\newblock Discovering non-linear ranking functions by solving semi-algebraic
  systems.
\newblock In C.~B. Jones, Zhiming Liu, and J.~Woodcock, editors, {\em Proc. of
  ICTAC 2007}, LNCS 4711, pages 34--49, Berlin, 2007. Springer.
}

\rf{21}{Ashutosh Gupta, Thomas~A. Henzinger, Rupak Majumdar, Andrey Rybalchenko, and
  Ru-Gang Xu.
\newblock Proving non-termination.
\newblock In George~C. Necula and Philip Wadler, editors, {\em Proc. of POPL
  2008}, pages 147--158, New York, 2008. ACM Press.}

\rf{22}{Byron Cook, Andreas Podelski, and Andrey Rybalchenko.
\newblock Termination proofs for systems code.
\newblock In Michael~I. Schwartzbach and Thomas Ball, editors, {\em Proc. of
  PLDI 2006}, pages 415--426, New York, 2006. ACM Press.}

\rf{23}{Helga Velroyen and Phillip R{\"{u}}mmer.
\newblock Non-termination checking for imperative programs.
\newblock In Bernhard Beckert and Reiner H{\"{a}}hnle, editors, {\em Proc. of
  TAP 2008}, LNCS 4966, pages 154--170, Berlin, 2008. Springer.}

\rf{24}{Marc Brockschmidt, Thomas Str{\"o}der, Carsten Otto, and J{\"u}rgen Giesl.
\newblock Automated detection of non-termination and
  \texttt{NullPointerExceptions} for {Java} bytecode.
\newblock In Bernhard Beckert, Ferruccio Damiani, and Dilian Gurov, editors,
  {\em Proc. of FoVeOOS 2011}, LNCS 7421, pages 123--141, Berlin, 2011.
  Springer.}

\rf{25}{P.~Cousot.
\newblock Proving program invariance and termination by parametric abstraction,
  {Lagrangian} relaxation and semidefinite programming.
\newblock In R.~Cousot, editor, {\em Proc. of VMCAI 2005}, LNCS 3385, pages
  1--24, Berlin, 2005. Springer.}

\rf{26}{L.~Shen, M.~Wu, Z.~Yang, and Z.~Zeng.
\newblock Finding positively invariant sets of a class of nonlinear loops via
  curve fitting. \newblock In Hiroshi Kai and Hiroshi Sekigawa, editors, {\em Proc. of SNC
  2009}, pages 185--190, New York, 2009. ACM Press.
  }

\rf{27}{David Cox, John Little, and Donal O'Shea.
\newblock {\em Ideals, Varieties, and Algorithms: An Introduction to
  Computational Algebraic Geometry and Commutative Algebra}.
\newblock UTM. Springer, Berlin, 3 edition, 2007.}

\rf{28}{Bican Xia and Lu~Yang.
\newblock An algorithm for isolating the real solutions of semi-algebraic
  systems.
\newblock {\em Journal of Symbolic Computation}, 34(5):461--477, 2002.}

\rf{29}{Bican Xia.
\newblock {DISCOVERER}: A tool for solving semi-algebraic systems.
\newblock {\em ACM SIGSAM Bulletin}, 41(2):102--103, 2007.}

\rf{30}{E.~W. Mayr.
\newblock Membership in polynomial ideals over $\mathbb{Q}$ is exponential
  space complete.
\newblock In B.~Monien and R.~Cori, editors, {\em Proc. of STACS 1989}, LNCS
  349, pages 400--406, Berlin, 1989. Springer.}

\end{document}







